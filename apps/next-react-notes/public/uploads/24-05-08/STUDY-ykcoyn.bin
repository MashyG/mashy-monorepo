# Next

## 路由（AppRouter && PageRouter）

> Nextjs 14+ 默认路由模式为 AppRouter
> 优先级：AppRouter > PageRouter

- `app/page.tsx` 对应路由 `/`
- `app/about/page.tsx` 对应路由 `/about`

## 定义布局（Layouts）

> layout 会包裹同层级的 Page

### 根布局（Root Layout）

> 布局支持嵌套，最顶层的布局我们称之为根布局（Root Layout）

```tsx
// app/layout.tsx
import "./globals.css";
import { Inter } from "next/font/google";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}
```

**注意**

1. `app` 目录必须包含根布局，也就是 `app/layout.tsx` 这个文件是必需的
2. 根布局必须包含 `html` 和 `body` 标签，其他布局不能包含这些标签
3. 可以使用路由组创建多个根布局
4. 默认根布局是服务端组件，且不能设置为客户端组件

### 定义模板（Templates）

> 模板类似于布局，它也会传入每个子布局或者页面。但**不会像布局那样维持状态**。

**注意：** layout 会包裹 template，template 又会包裹 page。

```tsx
<Layout>
  {/* 模板需要给一个唯一的 key */}
  <Template key={routeParam}>{children}</Template>
</Layout>
```

### 定义加载界面（Loading UI）

```tsx
// xxx/loading.tsx
export default function AboutLoading() {
  return <>Loading about...</>;
}

// xxx/page.tsx
import { use } from "react";

async function getData() {
  await new Promise((resolve) => setTimeout(resolve, 3000));
  return {
    message: "Hello, About!",
  };
}
export default function AboutPage(props) {
  // const { message } = await getData()
  const { message } = use(getData());
  return <h1>{message}</h1>;
}
```

> **原理**：利用 Suspense ,当发生路由变化的时候，立刻展示 fallback UI，等加载完成后，展示数据。

```tsx
// About 会 throw 一个数据加载的 promise，Suspense 会捕获这个 promise，追加一个 then 函数，then 函数中实现替换 fallback UI 。当数据加载完毕，promise 进入 resolve 状态，then 函数执行，于是更新替换 fallback UI。
<Suspense fallback={<Spinner />}>
  <AboutPage />
</Suspense>
```

### 定义错误处理（Error Handling）

> 用来创建发生错误时的展示 UI

```tsx
"use client"; // 错误组件必须是客户端组件
// xxx/error.tsx
import { useEffect } from "react";

export default function Error({ error, reset }) {
  useEffect(() => {
    console.error(error);
  }, [error]);

  return (
    <div>
      <h2>Something went wrong!</h2>
      <button
        onClick={
          // 尝试恢复
          () => reset()
        }
      >
        Try again
      </button>
    </div>
  );
}
```

**全局错误捕获**

```tsx
"use client";
// app/error.tsx
export default function GlobalError({ error, reset }) {
  return (
    <html>
      <body>
        <h2>Something went wrong!</h2>
        <button onClick={() => reset()}>Try again</button>
      </body>
    </html>
  );
}
```

### 定义 404 页面

> 特殊文件：not-found.tsx

```tsx
// xxx/not-found.tsx
import Link from "next/link";

export default function NotFound() {
  return (
    <div>
      <h2>Not Found</h2>
      <p>Could not find requested resource</p>
      <Link href="/">Return Home</Link>
    </div>
  );
}
```

### 总结

```tsx
app
  ├── page.tsx
  ├── layout.tsx
  ├── template.tsx
  ├── loading.tsx
  ├── error.tsx
  └── not-found.tsx
  ├── about
  │   └── page.tsx
```

## 导航

### 使用 <Link> 组件

> 一个拓展了原生 HTML <a> 标签的内置组件，用来实现预获取（prefetching） 和客户端路由导航

```tsx
import Link from "next/link";

// 基础用法
function About() {
  return <Link href="/about">About</Link>;
}

// 动态渲染
function PostList({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.id}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  );
}

// 获取当前URL路径（必须在客户端使用"use client"）
usePathname();
```

### 使用 useRouter() Hook（客户端组件）

```tsx
// 该 hook 需要在客户端组件中
"use client";

import { useRouter } from "next/navigation";

export default function Page() {
  const router = useRouter();

  return (
    <button type="button" onClick={() => router.push("/about")}>
      About
    </button>
  );
}
```

### 使用 redirect 函数（服务端组件）

> 客户端组件使用 `useRouter()` hook，服务端组件则可以直接使用 `redirect()` 函数

```tsx
redirect("/login");
```

### 使用浏览器原生 History API

> 浏览器原生的 `window.history.pushState` 和 `window.history.replaceState` 方法更新浏览器的历史记录堆栈.通常与 usePathname（获取路径名的 hook） 和 useSearchParams（获取页面参数的 hook） 一起使用

## 动态路由、路由组、平行路由和拦截路由

### 动态路由（Dynamic Routes）

#### `[folderName]`

> 使用动态路由，你需要将文件夹的名字用方括号括住，比如 [id]、[slug]。这个路由的名字会作为 params prop 传给布局、 页面、 路由处理程序 以及 generateMetadata 函数。

```tsx
// app/about/[mashy]/page.tsx
export default function Page({ params }: any) {
  return <div>Params: {params.mashy}</div>;
}
```

#### `[...folderName]`

```tsx
// app/about/[mashy]/[chen]/page.tsx
export default function Page({ params }: any) {
  return <div>Params: {JSON.stringify(params)}</div>; // {"mashy":"xxx","chen":"xxx"}
}
```

#### `[[...folderName]]`

> 在命名文件夹的时候，如果你在双方括号内添加省略号，比如 `[[...folderName]]`，这表示可选的捕获所有后面所有的路由片段。
> 与上一种的区别就在于，不带参数的路由也会被匹配（就比如 `/about`）

### 路由组（Route groups）

#### 按逻辑分组

> 将路由按逻辑分组，但不影响 URL 路径：

```tsx
app
  ├── page.tsx
  ├── (AI)
      ├── xxx
          └── page.tsx
      ├── yyy
          └── page.tsx
  ├── (file)
      ├── xxx
          └── page.tsx
      ├── yyy
          └── page.tsx
```

#### 创建不同布局

> 借助路由组，即便在同一层级，也可以创建不同的布局：

```tsx
app
  ├── page.tsx
  ├── (AI)
      ├── layout.tsx  // √
      ├── xxx
          └── page.tsx
      ├── yyy
          └── page.tsx
  ├── (file)
      ├── layout.tsx  // √
      ├── xxx
          └── page.tsx
      ├── yyy
          └── page.tsx
```

#### 创建多个根布局

```tsx
app
  ├── (AI)
      ├── layout.tsx  // √ 要有 <html> 和 <body> 标签
      ├── page.tsx
      ├── xxx
          └── page.tsx
      ├── yyy
          └── page.tsx
  ├── (file)
      ├── layout.tsx  // √ 要有 <html> 和 <body> 标签
      ├── xxx
          └── page.tsx
      ├── yyy
          └── page.tsx
```

**注意**

- 路由组的命名除了用于组织之外并无特殊意义。它们不会影响 URL 路径。
- 注意不要解析为相同的 URL 路径。举个例子，因为路由组不影响 URL 路径，所以 `(marketing)/about/page.js` 和 `(shop)/about/page.js` 都会解析为 `/about`，这会导致报错。
- 创建多个根布局的时候，因为删除了顶层的 `app/layout.js` 文件，访问 /会报错，所以 `app/page.js` 需要定义在其中一个路由组中。
- 跨根布局导航会导致页面完全重新加载，就比如使用 `app/(shop)/layout.js` 根布局的 `/cart` 跳转到使用 `app/(marketing)/layout.js` 根布局的 `/blog` 会导致页面重新加载（full page load）。

### 平行路由（Parallel Routes）

> 平行路由可以使你在同一个布局中同时或者有条件的渲染一个或者多个页面（类似于 Vue 的插槽功能）。

> **平行路由的使用方式是将文件夹以 @ 作为开头进行命名**

- 条件渲染：`isLogin ? <content /> : <login />`
- 独立路由处理：loading、error
- 子导航：@left/one、@left/two
- default.tsx

具体插槽中显示的内容其实跟导航的类型有关：

- 如果是软导航（Soft Navigation，比如通过 <Link /> 标签），在导航时，Next.js 将执行部分渲染，更改插槽的内容，如果它们与当前 URL 不匹配，维持之前的状态
- 如果是硬导航（Hard Navigation，比如浏览器刷新页面），因为 Next.js 无法确定与当前 URL 不匹配的插槽的状态，所以会渲染 404 错误

### 拦截路由

> 拦截路由允许你在当前路由拦截其他路由地址并在当前路由中展示内容。

在 Next.js 中，实现拦截路由需要你在命名文件夹的时候以 (..) 开头，其中：

- (.) 表示匹配同一层级
- (..) 表示匹配上一层级
- (..)(..) 表示匹配上上层级。
- (...) 表示匹配根目录

```js
// /food/(..)photo对应的路由是 /food/photo，要拦截的路由是 /photo，两者只差了一个层级，所以使用 (..)
app
  ├── page.tsx
  ├── food
      ├── (..)photo
          ├── [id]
              ├── page.tsx
      ├── layout.tsx
  ├── photo
      ├── [id]
          ├── page.tsx
```

## 路由处理程序

> 路由处理程序是指使用 `Web Request` 和 `Response API` 对于给定的路由自定义处理逻辑。
> 简单的来说，前后端分离架构中，客户端与服务端之间通过 API 接口来交互。这个“API 接口”在 Next.js 中有个更为正式的称呼，就是路由处理程序。
> 该文件必须在 app 目录下，可以在 app 嵌套的文件夹下，但是要注意 `page.tsx` 和 `route.ts` 不能在同一层级同时存在。
> `page.tsx` 和 `route.ts` 本质上都是对路由的响应。`page.tsx` 主要负责渲染 UI，`route.ts` 主要负责处理请求

```ts
import { NextResponse } from "next/server";

export async function GET() {
  const res = await fetch("https://jsonplaceholder.typicode.com/posts");
  const data = await res.json();

  // return Response.json({ data }); // 原生也可，Next推荐下面的
  return NextResponse.json({ data });
}
```

### 支持方法

> Next.js 支持 GET、POST、PUT、PATCH、DELETE、HEAD 和 OPTIONS 这些 HTTP 请求方法。

### 请求参数

```ts
export async function GET(request, context) {}
// request：request 对象是一个 NextRequest 对象，它是基于 Web Request API 的扩展。使用 request ，你可以快捷读取 cookies 和处理 URL
// context 只有一个值就是 params，它是一个包含当前动态路由参数的对象
```

### 缓存

> 默认情况下，使用 Response 对象（NextResponse 也是一样的）的 GET 请求会被缓存。
> 在构建的时候,被预渲染为静态的内容

#### 退出缓存方法

1. GET 请求使用 Request 对象
2. 添加其他 HTTP 方法，比如 POST
3. 使用像 cookies、headers 这样的动态函数
4. 路由段配置项手动声明为动态模式

```ts
export async function GET(request) {
  const token = request.cookies.get("token"); // 3
  return Response.json({ data: new Date().toLocaleTimeString() }); // 1
}

// 2
export async function POST() {
  console.log("POST /api/time");
  return Response.json({ data: new Date().toLocaleTimeString() });
}

export const dynamic = "force-dynamic"; // 4
```

**除了退出缓存，也可以设置缓存的时效，适用于一些重要性低、时效性低的页面**

1. 路由段配置项
2. 使用 `next.revalidate` 选项

```ts
export const revalidate = 10; // 1 表示设置重新验证频率为 10s

export async function GET() {
  return Response.json({ data: new Date().toLocaleTimeString() });
}

// 2
// Next.js 拓展了原生的 fetch 方法，会自动缓存 fetch 的结果。现在我们使用 next.revalidate 设置 fetch 请求的重新验证时间
export async function GET() {
  const res = await fetch("https://api.thecatapi.com/v1/images/search", {
    next: { revalidate: 5 }, //  每 5 秒重新验证
  });
  const data = await res.json();
  console.log(data);
  return Response.json(data);
}
```

## 路由中间件（Middleware）

> 使用中间件，你可以拦截并控制应用里的所有请求和响应。
> 中间件文件必须在根目录下

> 比如你可以基于传入的请求，重写、重定向、修改请求或响应头、甚至直接响应内容。一个比较常见的应用就是鉴权，在打开页面渲染具体的内容前，先判断用户是否登录，如果未登录，则跳转到登录页面。

```ts
// middleware.ts
import { NextResponse } from "next/server";

// 中间件可以是 async 函数，如果使用了 await
export function middleware(request: Request) {
  return NextResponse.redirect(new URL("/", request.url));
}

// 设置匹配路径
// matcher 不仅支持字符串形式，也支持数组形式，用于匹配多个路径
export const config = {
  // matcher: "/about/:path*",
  matcher: ["/about/:path*", "/boast/:path*"],
};
```

> `path-to-regexp` 通过在参数名前加一个冒号来定义命名参数（Named Parameters）
>
> 命名参数的默认匹配逻辑是 `[^/]+`，但你也可以在命名参数后加一个括号，在其中自定义命名参数的匹配逻辑，比如 `/about/icon-:foo(\\d+).png` 匹配 `/about/icon-1.png`，但不匹配 `/about/icon-a.png`。
>
> 命名参数可以使用修饰符，**其中 \* 表示 0 个或 1 个或多个，?表示 0 个或 1 个，+表示 1 个或多个**，比如
>
> - `/about/:path*` 匹配 `/about`、`/about/xxx`、`/about/xxx/xxx`
> - `/about/:path?` 匹配 `/about`、`/about/xxx`
> - `/about/:path+` 匹配 `/about/xxx`、`/about/xxx/xxx`
>
> 也可以在圆括号中使用标准的正则表达式，比如 `/about/(.*)` 等同于 `/about/:path*`，比如 · 匹配 `/about` 和 `/settings`，不匹配其他的地址。`/user-(ya|yu)` 匹配 `/user-ya` 和 `/user-yu`。

**注意**：路径必须以 /开头。matcher 的值必须是常量，这样可以在构建的时候被静态分析。使用变量之类的动态值会被忽略。

```ts
export const config = {
  matcher: [
    /*
     * 匹配所有的路径除了以这些作为开头的：
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    "/((?!api|_next/static|_next/image|favicon.ico).*)",
  ],
};
```

### matcher 还可以判断查询参数、cookies、headers

```ts
// 不仅匹配了路由地址，还要求 header 的 Authorization 必须是 Bearer Token，查询参数的 userId 为 123，且 cookie 里的 session 值不是 active。
export const config = {
  matcher: [
    {
      source: "/api/*",
      has: [
        { type: "header", key: "Authorization", value: "Bearer Token" },
        { type: "query", key: "userId", value: "123" },
      ],
      missing: [{ type: "cookie", key: "session", value: "active" }],
    },
  ],
};
```

### 利用 `NextResponse.next()` 读取和设置 `cookies` 或 `headers`

```ts
// middleware.ts
import { NextResponse } from "next/server";

export function middleware(request) {
  // 假设传入的请求 header 里 "Cookie:nextjs=fast"
  let cookie = request.cookies.get("nextjs");
  console.log(cookie); // => { name: 'nextjs', value: 'fast', Path: '/' }
  const allCookies = request.cookies.getAll();
  console.log(allCookies); // => [{ name: 'nextjs', value: 'fast' }]

  request.cookies.has("nextjs"); // => true
  request.cookies.delete("nextjs");
  request.cookies.has("nextjs"); // => false

  // 设置 cookies
  const response = NextResponse.next();
  response.cookies.set("vercel", "fast");
  response.cookies.set({
    name: "vercel",
    value: "fast",
    path: "/",
  });
  cookie = response.cookies.get("vercel");
  console.log(cookie); // => { name: 'vercel', value: 'fast', Path: '/' }

  // 响应 header 为 `Set-Cookie:vercel=fast;path=/test`
  // return response

  //  clone 请求标头
  const requestHeaders = new Headers(request.headers);
  requestHeaders.set("x-hello-from-middleware1", "hello");

  // 你也可以在 NextResponse.rewrite 中设置请求标头
  const response = NextResponse.next({
    request: {
      // 设置新请求标头
      headers: requestHeaders,
    },
  });

  // 设置新响应标头 `x-hello-from-middleware2`
  response.headers.set("x-hello-from-middleware2", "hello");
  return response;
}
```

### 利用 `NextResponse.next()` 设置 `CORS`

```ts
import { NextResponse } from "next/server";

const allowedOrigins = ["https://xxx.com", "https://my-app.org"];

const corsOptions = {
  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization",
};

export function middleware(request) {
  // Check the origin from the request
  const origin = request.headers.get("origin") ?? "";
  const isAllowedOrigin = allowedOrigins.includes(origin);

  // Handle preflighted requests
  const isPreflight = request.method === "OPTIONS";

  if (isPreflight) {
    const preflightHeaders = {
      ...(isAllowedOrigin && { "Access-Control-Allow-Origin": origin }),
      ...corsOptions,
    };
    return NextResponse.json({}, { headers: preflightHeaders });
  }

  // Handle simple requests
  const response = NextResponse.next();

  if (isAllowedOrigin) {
    response.headers.set("Access-Control-Allow-Origin", origin);
  }

  Object.entries(corsOptions).forEach(([key, value]) => {
    response.headers.set(key, value);
  });

  return response;
}

export const config = {
  matcher: "/api/:path*",
};
```

### 直接响应：使用 NextResponse 设置返回的 Response

```ts
return new NextResponse(
  JSON.stringify({ success: false, message: "authentication failed" }),
  { status: 401, headers: { "content-type": "application/json" } }
);
```

### 路由的响应执行顺序

1. headers（`next.config.js`）
2. redirects（`next.config.js`）
3. 中间件 (`rewrites, redirects` 等)
4. beforeFiles (`next.config.js 中的 rewrites`)
5. 基于文件系统的路由 (`public/, _next/static/, pages/, app/ 等`)
6. afterFiles (`next.config.js 中的 rewrites`)
7. 动态路由 (`/blog/[slug]`)
8. fallback 中的 (`next.config.js 中的 rewrites`)

### 中间件相关配置项：`skipTrailingSlashRedirect`（跳过尾部斜杠重定向） 和 `skipTrailingSlashRedirect`

#### `skipTrailingSlashRedirect`

> 当你设置 `skipTrailingSlashRedirect` 为 true 后，假设再次访问 `/about/`，URL 依然会是` /about/`。

#### `skipTrailingSlashRedirect`

> 设置 `skipMiddlewareUrlNormalize` 为 true 后，可以获取路由原始的地址，常用于国际化场景中。

### 运行时注意事项

> 使用 Middleware 的时候还要注意一点，那就是目前 Middleware 只支持 `Edge runtime`，并不支持 `Node.js runtime`。这意味着写 Middleware 的时候，尽可能使用 Web API，避免使用 Node.js API

### 多个中间件的情况

```ts
import { NextResponse } from "next/server";

// 工具方法
function chain(functions, index = 0) {
  const current = functions[index];
  if (current) {
    const next = chain(functions, index + 1);
    return current(next);
  }
  return () => NextResponse.next();
}

// 第一个中间件
function withMiddleware1(middleware) {
  return async (request) => {
    console.log("middleware1 " + request.url);
    return middleware(request);
  };
}

// 第二个中间件
function withMiddleware2(middleware) {
  return async (request) => {
    console.log("middleware2 " + request.url);
    return middleware(request);
  };
}

export default chain([withMiddleware1, withMiddleware2]); // 运行顺序：withMiddleware1, withMiddleware2

export const config = {
  matcher: "/api/:path*",
};
```

## 服务端组件和客户端组件

### 服务端组件

> 默认就是服务端组件

**🔅 优势 🔅**

1. **数据获取**：通常服务端环境（网络、性能等）更好，离数据源更近，在服务端获取数据会更快。通过减少数据加载时间以及客户端发出的请求数量来提高性能
2. **安全**：在服务端保留敏感数据和逻辑，不用担心暴露给客户端
3. **缓存**：服务端渲染的结果可以在后续的请求中复用，提高性能
4. **bundle 大小**：服务端组件的代码不会打包到 bundle 中，减少了 bundle 包的大小
5. **初始页面加载和 FCP**：服务端渲染生成 HTML，快速展示 UI
6. **Streaming**：服务端组件可以将渲染工作拆分为 chunks，并在准备就绪时将它们流式传输到客户端。用户可以更早看到页面的部分内容，而不必等待整个页面渲染完毕

**⚠️ 限制 ⚠️**

> 不能使用 useState 管理状态，不能使用浏览器的 API 等等

### 客户端组件

> 需要在文件顶部添加一个 `"use client"` 声明

**⚠️ 注意 ⚠️**："use client"用于声明服务端和客户端组件模块之间的边界。当你在文件中定义了一个 "use client"，导入的其他模块包括子组件，都会被视为客户端 bundle 的一部分。

**🔅 优势 🔅**

1. **交互性**：客户端组件可以使用 state、effects 和事件监听器，意味着用户可以与之交互
2. **浏览器 API**：客户端组件可以使用浏览器 API 如地理位置、localStorage 等

### **渲染环境**：服务端组件只会在服务端渲染，但客户端组件会在服务端渲染一次，然后在客户端渲染。

> 服务端组件运行在构建时和服务端，客户端组件运行在构建时、服务端（生成初始 HTML）和客户端（管理 DOM）

#### **服务端组件可以直接导入客户端组件，但客户端组件并不能导入服务端组件**

### 组件渲染原理

在服务端：

Next.js 使用 React API 编排渲染，渲染工作会根据路由和 Suspense 拆分成多个块（chunks），每个块分两步进行渲染：

1. React 将服务端组件渲染成一个特殊的数据格式称为 React Server Component Payload (RSC Payload)
2. Next.js 使用 RSC Payload 和客户端组件代码在服务端渲染 HTML

> RSC payload 中包含如下这些信息：
>
> 1. 服务端组件的渲染结果
> 2. 客户端组件占位符和引用文件
> 3. 从服务端组件传给客户端组件的数据

在客户端：

1. 加载渲染的 HTML 快速展示一个非交互界面（Non-interactive UI）
2. RSC Payload 会被用于协调（reconcile）客户端和服务端组件树，并更新 DOM
3. JavaScript 代码被用于水合客户端组件，使应用程序具有交互性（Interactive UI）

## 服务端渲染策略

### 静态渲染（Static Rendering）

> **默认渲染策略，路由在构建时渲染，或者在重新验证后后台渲染**，其结果会被缓存并且可以推送到 CDN。适用于未针对用户个性化且数据已知的情况，比如静态博客文章、产品介绍页面等。

### 动态渲染（Dynamic Rendering）

> 在渲染过程中，如果使用了动态函数（Dynamic functions）或者未缓存的数据请求（uncached data request），Next.js 就会切换为动态渲染

#### 使用动态函数（Dynamic functions）

> **动态函数指的是获取只有在请求时才能得到信息（如 cookie、请求头、URL 参数）的函数。**

在 Next.js 中这些动态函数是：

1. cookies() 和 headers() ：获取 cookie 和 header
2. searchParams：页面查询参数

#### 使用未缓存的数据请求（uncached data request）

在 Next.js 中，fetch 请求的结果默认会被缓存，但你可以设置退出缓存，一旦你设置了退出缓存，就意味着使用了未缓存的数据请求（uncached data request），会导致路由进入动态渲染，如：

1. fetch 请求添加了 `cache: 'no-store'` 选项
2. fetch 请求添加了 `revalidate: 0` 选项
3. fetch 请求在路由处理程序中并使用了 POST 方法
4. 在 headers 或 cookies 方法之后使用 fetch 请求
5. 配置了路由段选项 `const dynamic = 'force-dynamic'`
6. 配置了路由段选项 `fetchCache` ，默认会跳过缓存 ([例子](./app/cat/page.tsx))
7. fetch 请求使用了 `Authorization` 或者 `Cookie` 请求头，并且在组件树中其上方还有一个未缓存的请求

### `Streaming`

> 使用 `loading.tsx` 或者 `React Suspense` 组件会开启 `Streaming`

## Next.js 数据获取、缓存与重新验证

> Next.js 优先推荐使用原生的 fetch 方法，因为 Next.js 拓展了原生的 fetch 方法，为其添加了缓存和更新缓存(重新验证)的机制

### 默认缓存

> 默认情况下，Next.js 会自动缓存服务端 fetch 请求的返回值（背后用的是数据缓存（Data Cache））。

```ts
// fetch 的 cache 选项用于控制该请求的缓存行为
// 默认就是 'force-cache', 平时写的时候可以省略
fetch("https://...", { cache: "force-cache" });
```

但这些情况默认不会自动缓存：

1. 在 Server Action 中使用的时候
2. 在定义了非 GET 方法的路由处理程序中使用的时候

> **在服务端组件和只有 GET 方法的路由处理程序中使用 fetch，返回结果会自动缓存。**

#### logging 配置项

```ts
// next.config.mjs
const nextConfig = {
  logging: {
    fetches: {
      fullUrl: true,
    },
  },
};

export default nextConfig;
```

#### 服务端组件

> 在开发模式下，为了方便调试，可以使用浏览器的硬刷新清除缓存，此时数据会发生更改（cache: SKIP）。普通刷新时因为会命中缓存（cache: HIT），数据会保持不变。
> 而在生产模式下， fetch 请求的返回结果被缓存了，无论是否硬刷新，图片数据都会保持不变。

#### 路由处理程序 GET 请求

> 在开发模式下，浏览器硬刷新的时候会跳过缓存，普通刷新的时候则会命中缓存。
> 而在生产模式下，fetch 请求的返回结果被缓存了，无论是否硬刷新，接口数据都会保持不变。

```ts
// app/api/cache/route.ts
export async function GET() {
  const res = await fetch("https://dog.ceo/api/breeds/image/random");

  const data = await res.json();
  return Response.json({ data });
}
```

### 重新验证

> 在 Next.js 中，清除数据缓存并重新获取最新数据的过程就叫做重新验证（Revalidation）。

#### 基于时间的重新验证（Time-based revalidation）

> 即经过一定时间并有新请求产生后重新验证数据，适用于不经常更改且新鲜度不那么重要的数据。

```ts
// ① -> next.revalidate
fetch("https://...", { next: { revalidate: 3600 } });

// ② -> layout.jsx | page.jsx | route.js
export const revalidate = 3600;
```

#### 按需重新验证（On-demand revalidation）

> 根据事件手动重新验证数据。按需重新验证又可以使用基于标签（tag-based）和基于路径（path-based）两种方法重新验证数据。适用于需要尽快展示最新数据的场景。

**使用按需重新验证，在路由处理程序或者 Server Action 中通过路径（ revalidatePath） 或缓存标签 revalidateTag 实现。**

## 缓存机制

Next.js 中有四种缓存机制：

| 机制                             | 缓存内容            | 存储地方 | 目的                      | 期间               |
| -------------------------------- | ------------------- | -------- | ------------------------- | ------------------ |
| 请求记忆（Request Memoization）  | 函数返回值          | 服务端   | 在 React 组件树中复用数据 | 每个请求的生命周期 |
| 数据缓存（Data Cache ）          | 数据                | 服务端   | 跨用户请求和部署复用数据  | 持久（可重新验证） |
| 完整路由缓存（Full Route Cache） | HTML 和 RSC payload | 服务端   | 降低渲染成本、提高性能    | 持久（可重新验证） |
| 路由缓存（Router Cache）         | RSC payload         | 客户端   | 减少导航时的服务端请求    | 用户会话或基于时间 |

### 请求记忆（Request Memoization）

> React 拓展了 fetch API，当有相同的 URL 和参数的时候，React 会自动将请求结果缓存。也就是说，即时你在组件树中的多个位置请求一份相同的数据，但数据获取只会执行一次。

**⚠️ 注意 ⚠️**

1. **请求记忆是 React 的特性，并非 Next.js 的特性**。 React 和 Next.js 都做了请求缓存，React 的方案叫做“请求记忆”，Next.js 的方案叫做“数据缓存”，两者有很多不同
2. **请求记忆只适合用于用 GET 方法的 fetch 请求**
3. **请求记忆只应用于 React 组件树**，也就是说你在 `generateMetadata`、`generateStaticParams`、布局、页面和其他服务端组件中使用 fetch 会触发请求记忆，但是在路由处理程序中使用则不会触发，因为这就不在 React 组件树中了

### 数据缓存（Data Cache）

Next.js 有自己的数据缓存方案，可以跨服务端请求和构建部署存储数据。之所以能够实现，是因为 Next.js 拓展了 fetch API，在 Next.js 中，每个请求都可以设置自己的缓存方式。

不过与 React 的请求记忆不同的是，请求记忆因为只用于组件树渲染的时候，所以不用考虑数据缓存更新的情况，但 Next.js 的数据缓存方案更为持久，则需要考虑这个问题。

默认情况下，使用 fetch 的数据请求都会被缓存，这个缓存是持久的，它不会自动被重置。你可以使用 fetch 的 cache 和 `next.revalidate` 选项来配置缓存行为：

### **请求记忆和数据缓存的对比总结**

- **请求记忆**是 `React` 的数据缓存方案，它只持续在组件树渲染期间，目的是为了避免组件树渲染的时候多次请求同一数据造成的性能影响。
- **数据缓存**是 `Next.js` 的数据缓存方案，它可以跨部署和请求缓存，缓存数据不会失效，除非重新验证或者主动退出。目的在于优化应用性能。
- 实际项目开发的时候，请求记忆和数据缓存往往同时存在，共同作用。

### 完整路由缓存（Full Route Cache）

#### 工作原理

> Next.js 在构建的时候会自动渲染和缓存路由，这样当访问路由的时候，可以直接使用缓存中的路由而不用从零开始在服务端渲染，从而加快页面加载速度。

Next.js 使用 React 的 API 来编排渲染。当渲染的时候，渲染工作会根据路由和 Suspense 拆分成多个 chunk，每个 chunk 分为两步进行渲染：

1. React 会将服务端组件渲染成一种特殊的数据格式，我们称之为 `React Server Component Payload`，简写为 `RSC payload`

   > RSC payload 代码肯定是不能直接执行的，它包含的更多是信息：
   >
   > - 服务端组件的渲染结果
   > - 客户端组件的占位和引用文件
   > - 从服务端组件传给客户端组件的数据

2. Next.js 会用 RSC payload 和客户端组件代码在服务端渲染 HTML

#### 完整路由缓存默认是持久的，这意味着可以跨用户请求复用。

#### 失效方式

退出完整路由缓存的方式就是将其改为动态渲染：

1. 使用动态函数：使用动态函数后会改为动态渲染，此时数据缓存依然可以用
2. 使用路由段配置项：`dynamic = 'force-dynamic'`或 `revalidate = 0` 这会跳过完整路由缓存和数据缓存，也就是说，每次请求时都会重新获取数据并渲染组件。此时路由缓存依然可以用，毕竟它是客户端缓存
3. 退出数据缓存：如果路由中有一个 fetch 请求退出了缓存，则会退出完整路由缓存。这个特定的 fetch 请求会在每次请求时重新获取，其他 fetch 请求依然会使用数据缓存。Next.js 允许这种缓存和未缓存数据的混合

**简单来说，完整路由缓存只适用于静态渲染，在服务端保留静态渲染的产物 RSC Payload 和 HTML。**

### 路由缓存（Router Cache）

#### 工作原理

> Next.js 有一个存放在内存中的客户端缓存，它会在用户会话期间按路由段存储 RSC Payload。这就是路由缓存。

#### 生命周期

路由缓存存放在浏览器的临时缓存中，有两个因素决定了路由缓存的持续时间：

- Session，缓存在导航时持续存在，当页面刷新的时候会被清除
- 自动失效期：单个路由段会在特定时长后自动失效
  - 如果路由是静态渲染，持续 5 分钟
  - 如果路由是动态渲染，持续 30s

#### 失效方式

有两种方法可以让路由缓存失效：

- 在 `Server Action` 中
  - 通过 `revalidatePath` 或 `revalidateTag` 重新验证数据
  - 使用 `cookies.set` 或者 `cookies.delete` 会使路由缓存失效，这是为了防止使用 cookie 的路由过时（如身份验证）
- 调用 `router.refresh` 会使路由缓存失效并发起一个重新获取当前路由的请求

**无法退出路由缓存。你可以通过给 <Link> 组件的 prefetch 传递 false 来退出预获取，但依然会临时存储路由段 30s，这是为了实现嵌套路由段之间的即时导航**

### 总结

路由缓存和完整路由缓存的区别：

1. **路由缓存**发生在用户访问期间，将 RSC Payload 暂时存储在**浏览器**，导航期间都会持续存在，页面刷新的时候会被清除。而**完整路由缓存**则会持久的将 RSC Payload 和 HTML 缓存在**服务器**上
2. 完整路由缓存仅缓存静态渲染的路由，路由缓存可以应用于静态和动态渲染的路由

## Server Actions

> **Server Actions 是指在服务端执行的异步函数，它们可以在服务端和客户端组件中使用，以处理 Next.js 应用中的数据提交和更改。**

### 基本用法

定义一个 Server Action 需要使用 React 的 "use server" 指令。按指令的定义位置分为两种用法：

1. 将 "use server" 放到一个 async 函数的顶部表示该函数为 Server Action（函数级别）
2. 将 "use server" 放到一个单独文件的顶部表示该文件导出的所有函数都是 Server Actions（模块级别）

Server Actions 可以在服务端组件使用，也可以在客户端组件使用。

### 基本原理

1. Server Actions 背后使用的是 POST 请求方法，请求当前页面地址，根据 $ACTION_ID 区分
2. Server Actions 与 Next.js 的缓存和重新验证架构集成。调用 Action 时，Next.js 可以一次性返回更新的 UI 和新数据

### Server Actions 的好处

1. 代码更简洁。你也不需要手动创建接口，而且 Server Actions 是函数，这意味着它们可以在应用程序的任意位置中复用。
2. 当结合 form 使用的时候，支持渐进式增强。也就是说，即使禁用 JavaScript，表单也可以正常提交

> 使用 Server Actions 禁用和不禁用 JS 的差别是，不禁用的时候提交表单，页面不会刷新。禁用的时候提交表单页面会刷新

### Server Actions 的注意要点

1. Server Actions 的参数和返回值都必须是**可序列化**的，简单的说，JSON.stringfiy 这个值不出错
2. Server Actions 会继承使用的页面或者布局的运行时和路由段配置项，包括像 maxDuration 等字段

### Server Actions 处理表单提交时常搭配使用的一些 API

#### useFormStatus：用于返回表单提交的状态信息

#### useFormState：根据表单 action 的结果更新状态

[例子](app/todo/AddToDoForm.tsx)

**注意**：当使用 useFormState 的时候，对应 Server Action 函数的参数，第一个参数是 prevState，第二个参数是 formData。当使用 useFormStatus 的时候，要写在 form 下的单独的组件中

### Server Actions 注意要点

#### 获取提交的数据

如果使用 form action 这种最基本的形式，Server Action 函数第一个参数就是 formData

```tsx
export default function Page() {
  async function createInvoice(formData) {
    "use server";

    const rawFormData = {
      customerId: formData.get("customerId"),
    };

    // mutate data
    // revalidate cache
  }

  return <form action={createInvoice}>...</form>;
}
```

如果使用 form action + useFormState 这种形式，Server Actions 函数第一个参数是 prevState，第二个参数是 formData：

```tsx
"use client";

import { useFormState } from "react-dom";

export default function Home() {
  async function createTodo(prevState, formData) {
    return prevState.concat(formData.get("todo"));
  }

  const [state, formAction] = useFormState(createTodo, []);

  return (
    <form action={formAction}>
      <input type="text" name="todo" />
      <button type="submit">Submit</button>
      <p>{state.join(",")}</p>
    </form>
  );
}
```

#### 进行数据校验和错误处理

**Next.js 推荐基本的表单验证使用 HTML 元素自带的验证如 required、type="email"等。**

对于更高阶的服务端数据验证，可以使用 zod 这样的 schema 验证库来验证表单数据的结构

#### 重新验证数据

**Server Action 修改数据后，一定要注意重新验证数据，否则数据不会及时更新。**

> `revalidatePath` 或 `revalidateTag`

#### 错误处理

> 注意返回错误信息或抛出错误信息：`try-cattch` 或 `error.tsx`

### 乐观更新 useOptimistic

> 所谓乐观更新，举个例子，当用户点击一个点赞按钮的时候，传统的做法是等待接口返回成功时再更新 UI。乐观更新是先更新 UI，同时发送数据请求，至于数据请求后的错误处理，则根据自己的需要自定义实现。

[例子](app/todo/optimisticForm/page.tsx)

### Server Actions 常见问题

#### 处理 cookie

```ts
"use server";

import { cookies } from "next/headers";

export async function exampleAction() {
  // Get cookie
  const value = cookies().get("name")?.value;

  // Set cookie
  cookies().set("name", "Delba");

  // Delete cookie
  cookies().delete("name");
}
```

#### 重定向

```ts
"use server";

import { redirect } from "next/navigation";
import { revalidateTag } from "next/cache";

export async function createPost(id) {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag("todo"); // Update cached todo
  redirect(`/todo/${id}`); // Navigate to the new todo page
}
```

## 环境变量

Next.js 中添加环境变量：

1. 通过 `.env.local` 加载环境变量
2. 通过 `NEXT_PUBLIC_` 前缀在浏览器中获取环境变量

### `.env.local` 加载环境变量

> 在服务端组件或者路由处理程序中通过 `process.env` 获取环境变量；无法在浏览器端获取

```bash
# .env.local

DB_HOST=localhost

# 直接换行
PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----
...
Kh9NV...
...
-----END DSA PRIVATE KEY-----"

# 也可以使用 `\n`
PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----\nKh9NV...\n-----END DSA PRIVATE KEY-----\n"

# 使用 $引用其他变量
TEST_USER=nextjs
TEST_URL=https://TEST.com/$TEST_USER
# 本来就要用带 $的值，使用 \$这种方式进行转义
```

#### 在浏览器中获取环境变量

> 需要在变量前添加 NEXT*PUBLIC*前缀

```tsx
// .env.local
// NEXT_PUBLIC_mashy_id=mashy

// 使用
"use client";
// app/page.tsx
export default function Page() {
  return (
    <h1
      onClick={() => {
        console.log(process.env.NEXT_PUBLIC_mashy_id);
      }}
    >
      Hello World!
    </h1>
  );
}

// 注意：使用了变量，动态查找的值不会被内联！！！
// 使用了变量，不会被内联，不会生效
const varName = "NEXT_PUBLIC_ANALYTICS_ID";
setupAnalyticsService(process.env[varName]);

// 使用了变量，不会被内联，不会生效
const env = process.env;
setupAnalyticsService(env.NEXT_PUBLIC_ANALYTICS_ID);
```

#### 默认环境变量

**Next.js 支持在 .env（所有环境）、.env.development（开发环境）、.env.production（生产环境）中设置默认的值。**

**.env.local 会覆盖这些默认值。**

#### 测试环境变量

> 除了 development 环境和 production 环境，还有第三个选项，那就是 test 环境。这是当使用测试工具如 jest 或 cypress 时，出于测试目的而设置特定的环境变量。

> 用法跟开发环境、生产环境类似，建立一个 .env.test 文件用于测试环境，但是跟开发环境、生产环境不同的是，测试环境不会加载 .env.local 中的值，这是为了让每个人都产生相同的测试结果。这些默认值会在 NODE_DEV 设置成 test 的时候用到。

#### 环境变量加载顺序

1. `process.env`
2. `.env.$(NODE_ENV).local`
3. `.env.local` (当 `NODE_ENV` 是 `test` 的时候不会查找)
4. `.env.$(NODE_ENV)`
5. `.env`

## 目录结构

1. `/public` 目录继续放在项目根目录
2. `package.json、next.config.js、tsconfig.json` 等配置文件继续放在项目根目录
3. `.env.*` 文件继续放在项目根目录
4. 如果 `app` 或者 `pages` 在根目录下存在，`src/app` 或 `src/pages` 会被忽略。
5. 如果你正在使用 `src，你可能还需要移动其他应用文件夹，如` `/components 或 /lib`
6. 如果你正在使用中间件，确保它放在 `src` 目录下
7. 如果你正在使用 `Tailwind CSS`，别忘了修改 `tailwind.config.js` 中的 `content` 配置项

## 路由段配置项（Route Segment Config）

> 路由段配置选项可以配置页面、布局、路由处理程序的行为

```tsx
// layout.tsx | page.tsx | route.tsx
export const dynamic = "auto";
export const dynamicParams = true;
export const revalidate = false;
export const fetchCache = "auto";
export const runtime = "nodejs";
export const preferredRegion = "auto";
export const maxDuration = 5;

export default function MyComponent() {}
```

| 变量名            | 类型                                                                                                                                  | 默认值       |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------- | ------------ |
| `dynamic`         | `'auto'` 或 `'force-dynamic'` 或 `'error'` 或 `'force-static'`                                                                        | `'auto'`     |
| `dynamicParams`   | `boolean`                                                                                                                             | `true`       |
| `revalidate`      | `false` 或 `'force-cache'` 或 `0` 或 `number`                                                                                         | `false`      |
| `fetchCache`      | `'auto'` 或 `'default-cache'` 或 `'only-cache'` 或 `'force-cache'` 或 `'force-no-store'` 或 `'default-no-store'` 或 `'only-no-store'` | `'auto'`     |
| `runtime`         | `'nodejs'` 或 `'edge'`                                                                                                                | `'nodejs'`   |
| `preferredRegion` | `'auto'` 或 `'global'` 或 `'home'` 或 `string` 或 `string[]`                                                                          | `'auto'`     |
| `maxDuration`     | `number `                                                                                                                             | 部署平台设置 |

### `dynamic`：更改布局或者页面的动态行为

- `'auto'`（默认）：自动判断
- `'force-dynamic'`，强制动态渲染和退出所有 `fetch` 请求缓存，相当于：
  - Page Router 下使用了 `getServerSideProps()`
  - 将布局或页面中每个 `fetch()` 请求都设置为 `{ cache: 'no-store', next: { revalidate: 0 } }`
  - 设置了路由段配置 `export const fetchCache = 'force-no-store'`
- `'error'`强制静态渲染并缓存数据，如果有组件使用了动态函数或不缓存数据请求（uncached data request），就会导致错误，相当于：
  - Page Router 下使用了 `getStaticProps()`
  - 将布局或页面中每个 `fetch()` 请求都设置为 `{ cache: 'force-cache' }`
  - 设置了路由段配置 `fetchCache = 'only-cache', dynamicParams = false`
  - 设置 `dynamic = 'error'` 会更改 `dynamicParams` 的默认值 `true` 为 `false`
- `'force-static'` 强制静态渲染并缓存数据，强制 `cookies()`、`headers()`、`useSearchParams()` 返回空值。

### `dynamicParams`：控制当访问不是由 generateStaticParams 生成的动态路由段的时候发生什么。

- `true`（默认）：按需生成
- `false`：返回 404

> 如果使用了 `dynamic = 'error'` 和 `dynamic = 'force-static'`，它会更改 `dynamicParams` 的默认值为 `false`

### `revalidate`：设置布局或者页面的默认验证时间

> 此设置不会覆盖单个 `fetch` 请求设置的 `revalidate` 的值。注意 `revalidate` 选项只能用于 `Nodejs Runtime`，不能用于 `Edge Runtime`。

- `false`（默认），语义上相当于 `revalidate: Infinity`，资源无限期缓存。
- `0`，页面或布局总是动态渲染，即使没有使用动态函数或者不缓存数据请求（uncached data request）。
- `number` ：设置布局或页面的默认重新验证频率，以秒为单位。

### `fetchCache`：仅当你特别需要覆盖默认行为时才应该使用

> 默认情况下，Next.js 会缓存在动态函数使用之前的 fetch 请求，不会缓存任何动态函数之后的 fetch 请求。而 fetchCache 允许你覆盖布局或者页面中所有的 fetch 请求的默认 cache 选项。

- `'auto'`（默认）：动态函数之前按照开发者设置的 cache 选项进行缓存，动态函数之后不缓存请求
- `'default-cache'`：开发者可以自由设置 cache 选项，但如果开发者未设置 cache 选项，默认设置为 force-cache，这意味着即使是在动态函数之后的请求，也会被视为静态
- `'only-cache'`：如果开发者未设置 cache 选项，默认设置为 force-cache，如果有请求设置成 cache: 'no-store'，则会导致报错
- `'force-cache'`：将所有请求的 cache 选项设置为 force-cache 。
- `'default-no-store'`：开发者可以自由设置 cache 选项，但如果开发者未设置 cache 选项，默认设置为 no-store，这意味着即使是在动态函数之前的请求，也会被视为动态。
- `'only-no-store'`：如果开发者未设置 cache 选项，默认设置为 no-store，如果有请求设置成 cache: 'force-cache'，则会导致报错
- `'force-no-store'`：将所有请求的 cache 选项设置为 no-store 。

### `runtime`：设置运行时环境

### `preferredRegion`：指定区域

```tsx
// layout.tsx | page.tsx | route.ts
export const preferredRegion = "auto";
// 'auto' | 'global' | 'home' | ['iad1', 'sfo1']
// 其中 iad1 表示美国东部区域，参考位置美国华盛顿地区，sfo1 表示美国西部，参考位置美国旧金山。
```

### `maxDuration`

> 指的是函数在响应之前可以处理 HTTP 请求的最长时间。如果持续时间内没有响应，则会返回错误码。如果没有指定，根据不同的部署平台，默认时间会不同。

### `generateStaticParams`：与动态路由搭配使用，用于定义静态生成的路由段参数

## 内置组件 `<Image />`

优化内容：

1. **尺寸优化**：自动为每个设备提供正确尺寸的图片，也会使用现代图片格式如 WebP 和 AVIF。
2. **视觉稳定性**：防止图片加载时发生布局偏移（Layout Shift）
3. **更快的页面加载**：图片只有在进入视口的时候才会加载，使用懒加载功能，并可选使用模糊占位符
4. **灵活配置**：按需进行图片调整，远程服务器上的图片也可以

## `next/font` 字体

> `next/font` 会自动优化字体（包括自定义字体），就比如借助 CSS 的 `size-adjust` 属性实现零布局偏移。
> `next/font` 具体又分为 `next/font/google` 和 `next/font/local`

## 内置 `<Link>` 和 `<Script>` 组件

### `<Link>`

> Link 组件是一个拓展了 HTML `<a>` 元素的 React 组件，提供了预加载和客户端路由之间的导航功能。它是 Next.js 路由导航的主要方式

```tsx
// app/page.tsx
import Link from "next/link";

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>;
}
```

| Prop     | 示例              | 类型             | 是否必须 | 备注                               |
| -------- | ----------------- | ---------------- | -------- | ---------------------------------- |
| href     | href="/dashboard" | String or Object | 是       | -                                  |
| replace  | replace={false}   | Boolean          | -        | -                                  |
| scroll   | scroll={false}    | Boolean          | -        | -                                  |
| prefetch | prefetch={false}  | Boolean          | -        | 后台预获取页面(仅在生产环境中开启) |

### `<Script>`

> Next.js 内置的脚本组件，用于控制加载和执行三方脚本文件

| Prop     | 示例                  | 类型     | 是否必传                                                                             |
| -------- | --------------------- | -------- | ------------------------------------------------------------------------------------ |
| src      | src="xxxx"            | String   | 必传，除非使用内联脚本(注意必须为内联脚本分配一个 id，以保证 Next.js 追踪和优化脚本) |
| strategy | strategy="lazyOnload" | String   | -                                                                                    |
| onLoad   | onLoad={onLoadFunc}   | Function | -                                                                                    |
| onReady  | onReady={onReadyFunc} | Function | -                                                                                    |
| onError  | onError={onErrorFunc} | Function | -                                                                                    |

### `strategy`

脚本加载策略，一共有四种：

1. `beforeInteractive`： 在可交互前加载，适用于如机器人检测、`Cookie` 管理等
2. `afterInteractive`：**默认值**，在可交互后加载，适用于如数据统计等
3. `lazyOnload`：在浏览器空闲时间加载
4. `worker`：（实验性质）通过 `web worker` 加载

## `Metadata`

`<meta charset="utf-8" />`

**添加元数据**的方法分为两类：

1. 基于配置的元数据：在 `layout.js` 或 `page.js` 中导出一个静态 `metadata` 对象(静态元数据)或者一个动态的 `generateMetadata` 函数(动态元数据)。
2. 基于文件的元数据：添加一个静态或者动态生成的特殊文件

通过这些选项，Next.js 会自动为页面生成相关的 `<head>` 元素。

### 基于配置的元数据（Config-based）

#### 静态元数据

> 导出一个 Metadata 对象

```tsx
// layout.tsx | page.tsx
export const metadata = {
  title: "...",
  description: "...",
};

export default function Page() {}
```

#### 动态元数据

> 动态元数据是指依赖动态信息如当前路由参数、外部数据、父级路由段 metadata 等信息的元数据。要定义动态元数据，需要导出一个名为 generateMetadata 的函数，该函数返回一个 Metadata 对象

参数：`props` 指的是包含当前路由参数的对象，该对象又有两个字段，一个是 `params` (包含当前动态路由参数的对象)，一个是 `searchParams`(包含当前 URL 搜索参数的对象)

```tsx
// app/products/[id]/page.tsx
export async function generateMetadata({ params, searchParams }, parent) {
  // 读取路由参数
  const id = params.id;

  // 获取数据
  const product = await fetch(`https://.../${id}`).then((res) => res.json());

  // 获取和拓展父路由段 metadata
  const previousImages = (await parent).openGraph?.images || [];

  return {
    title: product.title,
    openGraph: {
      images: ["/some-specific-page-image.jpg", ...previousImages],
    },
  };
}

export default function Page({ params, searchParams }) {}
```

**注意：无论是静态元数据还是动态元数据都只在服务端组件中支持。如果不依赖运行时的信息，则应该尽可能使用静态元数据方式。**

### 基于文件的元数据（File-based）

特殊文件：

- `favicon.ico`、`apple-icon.jpg` 和 `icon.jpg`
- `opengraph-image.jpg` 和 `twitter-image.jpg`
- `robots.txt`（站点地图，用于帮助搜索引擎更高效的爬取网站）
- `sitemap.xml`（站点地图，用于帮助搜索引擎更高效的爬取网站）

## 懒加载

在 Next.js 中有两种方式实现懒加载：

1. 使用 `React.lazy()` 和 `Suspense`
2. 使用 `next/dynamic` 实现动态导入

默认情况下，服务端组件自动进行代码分隔，并且可以使用流将 UI 片段逐步发送到客户端，所以懒加载应用于客户端

### 使用 `React.lazy()` 和 `Suspense`

```tsx
import { useState, Suspense, lazy } from "react";
import Loading from "./Loading.js";

const MarkdownPreview = lazy(() =>
  delayForDemo(import("./MarkdownPreview.js"))
);

export default function MarkdownEditor() {
  const [showPreview, setShowPreview] = useState(false);
  const [markdown, setMarkdown] = useState("Hello, **world**!");
  return (
    <>
      <textarea
        value={markdown}
        onChange={(e) => setMarkdown(e.target.value)}
      />
      <label>
        <input
          type="checkbox"
          checked={showPreview}
          onChange={(e) => setShowPreview(e.target.checked)}
        />
        Show preview
      </label>
      <hr />
      {showPreview && (
        <Suspense fallback={<Loading />}>
          <h2>Preview</h2>
          <MarkdownPreview markdown={markdown} />
        </Suspense>
      )}
    </>
  );
}

// 添加一个固定的延迟时间，以便你可以看到加载状态
function delayForDemo(promise) {
  return new Promise((resolve) => {
    setTimeout(resolve, 2000);
  }).then(() => promise);
}
```

### 使用 `next/dynamic`

```tsx
import dynamic from "next/dynamic";

const WithCustomLoading = dynamic(
  () => import("../components/WithCustomLoading"),
  {
    loading: () => <p>Loading...</p>,
    ssr: false, // ⚠️ 跳过 ssr
  }
);

export default function Page() {
  return (
    <div>
      <WithCustomLoading />
    </div>
  );
}
```

**注意事项**：

1. import() 中的路径不能是模板字符串或者是变量
2. import() 必须在 dynamic() 中调用
3. dynamic() 跟 lazy() 函数一样，需要放在模块顶层
