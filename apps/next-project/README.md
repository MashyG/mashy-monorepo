# Next

## 路由（AppRouter && PageRouter）

> Nextjs 14+ 默认路由模式为 AppRouter
> 优先级：AppRouter > PageRouter

- `app/page.tsx` 对应路由 `/`
- `app/about/page.tsx` 对应路由 `/about`

## 定义布局（Layouts）

> layout 会包裹同层级的 Page

### 根布局（Root Layout）

> 布局支持嵌套，最顶层的布局我们称之为根布局（Root Layout）

```tsx
// app/layout.tsx
import "./globals.css";
import { Inter } from "next/font/google";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}
```

**注意**

1. `app` 目录必须包含根布局，也就是 `app/layout.tsx` 这个文件是必需的
2. 根布局必须包含 `html` 和 `body` 标签，其他布局不能包含这些标签
3. 可以使用路由组创建多个根布局
4. 默认根布局是服务端组件，且不能设置为客户端组件

### 定义模板（Templates）

> 模板类似于布局，它也会传入每个子布局或者页面。但**不会像布局那样维持状态**。

**注意：** layout 会包裹 template，template 又会包裹 page。

```tsx
<Layout>
  {/* 模板需要给一个唯一的 key */}
  <Template key={routeParam}>{children}</Template>
</Layout>
```

### 定义加载界面（Loading UI）

```tsx
// xxx/loading.tsx
export default function AboutLoading() {
  return <>Loading about...</>;
}

// xxx/page.tsx
import { use } from "react";

async function getData() {
  await new Promise((resolve) => setTimeout(resolve, 3000));
  return {
    message: "Hello, About!",
  };
}
export default function AboutPage(props) {
  // const { message } = await getData()
  const { message } = use(getData());
  return <h1>{message}</h1>;
}
```

> **原理**：利用 Suspense ,当发生路由变化的时候，立刻展示 fallback UI，等加载完成后，展示数据。

```tsx
// About 会 throw 一个数据加载的 promise，Suspense 会捕获这个 promise，追加一个 then 函数，then 函数中实现替换 fallback UI 。当数据加载完毕，promise 进入 resolve 状态，then 函数执行，于是更新替换 fallback UI。
<Suspense fallback={<Spinner />}>
  <About />
</Suspense>
```

### 定义错误处理（Error Handling）

> 用来创建发生错误时的展示 UI

```tsx
"use client"; // 错误组件必须是客户端组件
// xxx/error.tsx
import { useEffect } from "react";

export default function Error({ error, reset }) {
  useEffect(() => {
    console.error(error);
  }, [error]);

  return (
    <div>
      <h2>Something went wrong!</h2>
      <button
        onClick={
          // 尝试恢复
          () => reset()
        }
      >
        Try again
      </button>
    </div>
  );
}
```

**全局错误捕获**

```tsx
"use client";
// app/error.tsx
export default function GlobalError({ error, reset }) {
  return (
    <html>
      <body>
        <h2>Something went wrong!</h2>
        <button onClick={() => reset()}>Try again</button>
      </body>
    </html>
  );
}
```

### 定义 404 页面

> 特殊文件：not-found.tsx

```tsx
// xxx/not-found.tsx
import Link from "next/link";

export default function NotFound() {
  return (
    <div>
      <h2>Not Found</h2>
      <p>Could not find requested resource</p>
      <Link href="/">Return Home</Link>
    </div>
  );
}
```

### 总结

```tsx
app
  ├── page.tsx
  ├── layout.tsx
  ├── template.tsx
  ├── loading.tsx
  ├── error.tsx
  └── not-found.tsx
  ├── about
  │   └── page.tsx
```

## 导航

### 使用 <Link> 组件

> 一个拓展了原生 HTML <a> 标签的内置组件，用来实现预获取（prefetching） 和客户端路由导航

```tsx
import Link from "next/link";

// 基础用法
function About() {
  return <Link href="/about">About</Link>;
}

// 动态渲染
function PostList({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.id}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  );
}

// 获取当前URL路径（必须在客户端使用"use client"）
usePathname();
```

### 使用 useRouter() Hook（客户端组件）

```tsx
// 该 hook 需要在客户端组件中
"use client";

import { useRouter } from "next/navigation";

export default function Page() {
  const router = useRouter();

  return (
    <button type="button" onClick={() => router.push("/about")}>
      About
    </button>
  );
}
```

### 使用 redirect 函数（服务端组件）

> 客户端组件使用 `useRouter()` hook，服务端组件则可以直接使用 `redirect()` 函数

```tsx
redirect("/login");
```

### 使用浏览器原生 History API

> 浏览器原生的 `window.history.pushState` 和 `window.history.replaceState` 方法更新浏览器的历史记录堆栈.通常与 usePathname（获取路径名的 hook） 和 useSearchParams（获取页面参数的 hook） 一起使用

## 动态路由、路由组、平行路由和拦截路由

### 动态路由（Dynamic Routes）

#### `[folderName]`

> 使用动态路由，你需要将文件夹的名字用方括号括住，比如 [id]、[slug]。这个路由的名字会作为 params prop 传给布局、 页面、 路由处理程序 以及 generateMetadata 函数。

```tsx
// app/about/[mashy]/page.tsx
export default function Page({ params }: any) {
  return <div>Params: {params.mashy}</div>;
}
```

#### `[...folderName]`

```tsx
// app/about/[mashy]/[chen]/page.tsx
export default function Page({ params }: any) {
  return <div>Params: {JSON.stringify(params)}</div>; // {"mashy":"xxx","chen":"xxx"}
}
```

#### `[[...folderName]]`

> 在命名文件夹的时候，如果你在双方括号内添加省略号，比如 `[[...folderName]]`，这表示可选的捕获所有后面所有的路由片段。
> 与上一种的区别就在于，不带参数的路由也会被匹配（就比如 `/about`）

### 路由组（Route groups）

#### 按逻辑分组

> 将路由按逻辑分组，但不影响 URL 路径：

```tsx
app
  ├── page.tsx
  ├── (AI)
      ├── xxx
          └── page.tsx
      ├── yyy
          └── page.tsx
  ├── (file)
      ├── xxx
          └── page.tsx
      ├── yyy
          └── page.tsx
```

#### 创建不同布局

> 借助路由组，即便在同一层级，也可以创建不同的布局：

```tsx
app
  ├── page.tsx
  ├── (AI)
      ├── layout.tsx  // √
      ├── xxx
          └── page.tsx
      ├── yyy
          └── page.tsx
  ├── (file)
      ├── layout.tsx  // √
      ├── xxx
          └── page.tsx
      ├── yyy
          └── page.tsx
```

#### 创建多个根布局

```tsx
app
  ├── (AI)
      ├── layout.tsx  // √ 要有 <html> 和 <body> 标签
      ├── page.tsx
      ├── xxx
          └── page.tsx
      ├── yyy
          └── page.tsx
  ├── (file)
      ├── layout.tsx  // √ 要有 <html> 和 <body> 标签
      ├── xxx
          └── page.tsx
      ├── yyy
          └── page.tsx
```

**注意**

- 路由组的命名除了用于组织之外并无特殊意义。它们不会影响 URL 路径。
- 注意不要解析为相同的 URL 路径。举个例子，因为路由组不影响 URL 路径，所以 `(marketing)/about/page.js` 和 `(shop)/about/page.js` 都会解析为 `/about`，这会导致报错。
- 创建多个根布局的时候，因为删除了顶层的 `app/layout.js` 文件，访问 /会报错，所以 `app/page.js` 需要定义在其中一个路由组中。
- 跨根布局导航会导致页面完全重新加载，就比如使用 `app/(shop)/layout.js` 根布局的 `/cart` 跳转到使用 `app/(marketing)/layout.js` 根布局的 `/blog` 会导致页面重新加载（full page load）。

### 平行路由（Parallel Routes）

> 平行路由可以使你在同一个布局中同时或者有条件的渲染一个或者多个页面（类似于 Vue 的插槽功能）。

> **平行路由的使用方式是将文件夹以 @ 作为开头进行命名**

- 条件渲染：`isLogin ? <content /> : <login />`
- 独立路由处理：loading、error
- 子导航：@left/one、@left/two
- default.tsx

具体插槽中显示的内容其实跟导航的类型有关：

- 如果是软导航（Soft Navigation，比如通过 <Link /> 标签），在导航时，Next.js 将执行部分渲染，更改插槽的内容，如果它们与当前 URL 不匹配，维持之前的状态
- 如果是硬导航（Hard Navigation，比如浏览器刷新页面），因为 Next.js 无法确定与当前 URL 不匹配的插槽的状态，所以会渲染 404 错误

### 拦截路由

> 拦截路由允许你在当前路由拦截其他路由地址并在当前路由中展示内容。

在 Next.js 中，实现拦截路由需要你在命名文件夹的时候以 (..) 开头，其中：

- (.) 表示匹配同一层级
- (..) 表示匹配上一层级
- (..)(..) 表示匹配上上层级。
- (...) 表示匹配根目录

```js
// /food/(..)photo对应的路由是 /food/photo，要拦截的路由是 /photo，两者只差了一个层级，所以使用 (..)
app
  ├── page.tsx
  ├── food
      ├── (..)photo
          ├── [id]
              ├── page.tsx
      ├── layout.tsx
  ├── photo
      ├── [id]
          ├── page.tsx
```
