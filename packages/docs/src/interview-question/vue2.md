# `data` 为什么要返回一个函数？

为了保证每个组件实例可以维护一份被返回对象的独立的拷贝。
如果 `data` 直接是一个对象，那么它就不再是独立的，当 `data` 在多个组件间共享时，一旦在一个组件中改变了 `data`，其他的组件也会受到影响

# `v-if` 和 `v-for` 为什么不推荐同时使用？

1. 优先级问题：`v-for` 的优先级高于 `v-if`，如果同时使用，每次渲染都会先执行 `v-for`，然后在每个循环中执行 `v-if`，这样会导致**性能问题**，因为 `v-for` 需要遍历整个列表，无论 `v-if` 的条件是否满足。

2. 可读性问题：同时使用 `v-if` 和 `v-for` 会**使模板变得复杂，不易于理解和维护**。通常我们可以通过**计算属性**来替代这种用法，将筛选逻辑放在计算属性中，使模板保持简洁。

# `key` 有什么作用？

`key` 是一个特殊的属性，主要用于 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。
如果不使用 `key`，Vue 会使用一种最大限度减少动态元素并尽可能的尝试就地修改/复用相同类型元素的**算法 ①** 。而使用 key，它会基于 `key` 的变化重新排列元素顺序，并且会移除 `key` 不存在的元素。

有了 `key`，Vue 可以更准确地判断哪些元素对应哪些节点，从而更准确地进行 DOM 更新，提高应用性能。

> **①** “就地更新”：主要思想是尽可能地复用现有的 DOM 节点，而不是创建新的节点。
> 在进行列表渲染时，如果没有提供 key 属性，Vue 会尽量就地复用和修改 DOM 节点，而不是移动或删除旧节点然后创建新节点。这样可以提高渲染性能，因为操作 DOM 是非常消耗性能的。
>
> 但是，这种就地复用的策略有时候可能会导致一些不可预期的行为，特别是在涉及到状态保持或者节点的生命周期钩子函数时。因此，Vue 推荐在进行列表渲染时，总是提供 key 属性。

# `虚拟 DOM` 和 `diff` 算法的原理？

## 虚拟 `DOM`

是一个在内存中的轻量级 `JavaScript 对象`，它是`实际 DOM 的抽象表示`。Vue 通过虚拟 DOM 来**跟踪组件的状态变化**。当状态发生变化时，Vue 会生成一个新的虚拟 DOM，并将新旧虚拟 DOM 进行对比。

## diff 算法

是 Vue 在对比新旧虚拟 DOM 时使用的算法。

`diff 算法`的工作原理如下：

1. Vue 会遍历新的虚拟 DOM 树，并尝试找到与旧的虚拟 DOM 树相同的 "节点"。
2. 如果找到了相同的节点，Vue 会**更新**这个节点的属性和事件。
3. 如果没有找到相同的节点，Vue 会创建一个新的节点，并将其**添加**到真实的 DOM 中。
4. 如果在旧的虚拟 DOM 树中存在节点，而在新的虚拟 DOM 树中不存在，Vue 会**删除**这个节点。

> 解释**更新**操作：
>
> **节点类型不同**：如果新旧节点的类型不同，例如一个是 div 节点，一个是 p 节点，那么 Vue 会直接删除旧节点，并创建并插入新节点。
>
> **节点类型相同，但是属性不同**：如果新旧节点的类型相同，但是属性不同，例如 class 或 style 不同，那么 Vue 会复用旧节点，并更新其属性。
>
> **文本节点内容不同**：如果新旧节点都是文本节点，但是内容不同，那么 Vue 会直接更新文本内容。
>
> **列表节点中的子节点不同**：如果新旧节点都是列表节点，那么 Vue 会递归地对子节点进行 diff。这时候 key 属性就显得非常重要，因为 Vue 会根据 key 来判断哪些子节点可以复用。

# `computed` 计算属性如何缓存？

在 Vue 中，每个计算属性都有一个对应的 watcher 实例，这个 watcher 实例负责追踪计算属性的依赖（也就是计算属性的 getter 函数中访问的响应式数据）。

当我们访问一个计算属性时，Vue 会先检查这个计算属性对应的 `watcher`。`watcher` 有一个属性叫做 `dirty`，这个属性用来标记计算属性的依赖是否发生了变化。

- ① 如果 `dirty` 是 `true`，说明依赖的数据发生了变化，那么 `watcher` 会重新运行 `getter` 函数来计算新的结果，并将新的结果保存起来，同时将 `dirty` 设置为 `false`。
- ② 如果 `dirty` 是 `false`，说明依赖的数据没有变化，那么 `watcher` 就不会重新运行 `getter` 函数，而是直接返回上一次计算的结果。

```ts
// Vue2 源码（src\core\instance\state.ts）
function createComputedGetter(key) {
  return function computedGetter() {
    const watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate(); // ①
      }
      if (Dep.target) {
        if (__DEV__ && Dep.target.onTrack) {
          Dep.target.onTrack({
            effect: Dep.target,
            target: this,
            type: TrackOpTypes.GET,
            key,
          });
        }
        watcher.depend();
      }
      return watcher.value; // ②
    }
  };
}
```

# 计算属性 `computed` 和 侦听属性 `watch` 有何区别？

1. 从**使用场**景来看：计算属性适合用在模板渲染中，某个值是*依赖了其它的响应式对象甚至是其它计算属性计算得来的*；而侦听属性适用于*观测某个值的变化去完成一段复杂的业务逻辑*。
2. 从**内部实现**来看：计算属性和侦听属性在 Vue 内部都是通过 watcher 来实现的，但是它们的工作方式不同。计算属性的 watcher 会*缓存*计算结果，并且只有在依赖数据改变时才会重新计算。而侦听属性的 watcher 在数据每次改变时都会执行回调函数。

# `watch` 内部实现是怎样的？

在 Vue 中，watch 选项的内部实现主要依赖于 Vue 的响应式系统和 Watcher 类。

当你在 Vue 实例中定义了 watch 选项时，Vue 会遍历 watch 对象的每一个属性，对每一个属性创建一个 Watcher 实例。这个 Watcher 实例的任务就是观察它所对应的属性值的变化。

Watcher 实例在创建时，会读取它所对应的属性的当前值，并收集这个属性的依赖。这个过程是通过调用属性的 getter 函数完成的。在这个过程中，Watcher 实例会被添加到这个属性的依赖列表中。

当这个属性的值发生变化时，Vue 的响应式系统会通知所有依赖这个属性的 Watcher 实例。Watcher 实例在接到通知后，会重新读取属性的新值，并调用 watch 选项中定义的回调函数，将新值和旧值作为参数传入。
