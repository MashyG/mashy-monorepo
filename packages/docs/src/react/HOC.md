# 高阶组件 - HOC

> 高阶函数就是一个将函数作为参数并且返回值也是函数的函数。高阶组件是以组件作为参数，返回组件的函数。返回的组件把传进去的组件进行功能强化。

> HOC 的产生根本作用就是解决大量的**代码复用，逻辑复用**问题
>
> HOC 还有一个重要的作用就是让 **props** 中混入一些你需要的东西
>
> HOC 还可以对组件做一些**赋**能工作，比如对组件内的点击事件做一些监控，或者加一次额外的生命周期

### 属性代理

> 用组件包裹一层代理组件，在代理组件上，可以做一些，对源组件的强化操作

```jsx
function HOC(WrapComponent) {
  return class Advance extends React.Component {
    state = {
      name: "alien",
    };
    render() {
      return <WrapComponent {...this.props} {...this.state} />;
    }
  };
}
```

优点：

1. 属性代理可以和业务组件**低耦合，零耦合**，对于条件渲染和 props 属性增强，只负责控制子组件渲染和传递额外的 props 就可以了，所以无须知道，业务组件做了些什么。所以正向属性代理，更适合做一些开源项目的 HOC ，目前开源的 HOC 基本都是通过这个模式实现的。
2. 同样适用于类组件和函数组件。
3. 可以完全隔离业务组件的渲染，因为属性代理说白了是一个新的组件，相比反向继承，可以完全控制业务组件是否渲染。
4. 可以**嵌套使用**，多个 HOC 是可以嵌套使用的，而且一般不会限制包装 HOC 的先后顺序。

缺点：

1. 一般无法直接获取原始组件的状态，如果想要获取，需要 ref 获取组件实例。
2. 无法直接继承静态属性。如果需要继承需要手动处理，或者引入第三方库。
3. 因为本质上是产生了一个新组件，所以需要配合 forwardRef 来转发 ref。

### 反向继承

> 反向继承和属性代理有一定的区别，在于包装后的组件继承了原始组件本身，所以此时无须再去挂载业务组件。

```jsx
class Index extends React.Component {
  render() {
    return <div> hello,world </div>;
  }
}
function HOC(Component) {
  return class wrapComponent extends Component {
    /* 直接继承需要包装的组件 */
  };
}
export default HOC(Index);
```

优点：

1. 方便**获取组件内部状态**，比如 state ，props ，生命周期，绑定的事件函数等。
2. es6 继承可以良好继承静态属性。所以无须对静态属性和方法进行额外的处理。

缺点：

1. **函数组件无法使用**。
2. 和被包装的组件**耦合度高**，需要知道被包装的原始组件的内部状态，具体做了些什么？
3. 如果多个反向继承 HOC 嵌套在一起，当前状态会覆盖上一个状态。这样带来的隐患是非常大的，比如说有多个 componentDidMount ，当前 componentDidMount 会覆盖上一个 componentDidMount 。这样副作用串联起来，影响很大。
